import itertools
import random
import time
from functools import lru_cache

# ----------------------------------------------
# 1. Generalized Caching Function for t-Subsets
# ----------------------------------------------
@lru_cache(maxsize=None)
def get_ticket_t_subsets(ticket, t):
    """
    Given a ticket (a tuple of sorted numbers), compute all bitmask representations
    of its t-number subsets. This function is generic: it works for any t (with ticket size k >= t).
    
    Args:
        ticket (tuple): A sorted tuple of numbers (e.g., (3, 7, 11, 20, 35, 49)).
        t (int): The size of the subsets to extract.
    
    Returns:
        tuple: A tuple containing the bitmask (integer) for each t-element subset.
    """
    subsets_bitmasks = []
    for subset in itertools.combinations(ticket, t):
        mask = 0
        for num in subset:
            mask |= 1 << (num - 1)
        subsets_bitmasks.append(mask)
    return tuple(subsets_bitmasks)

# ----------------------------------------------
# 2. Universe Generation: All t-Subsets as Bitmasks
# ----------------------------------------------
def generate_universe(n, t):
    """
    Generate the universe of all t-element subsets (as bitmasks) from the set {1, 2, ..., n}.
    
    Args:
        n (int): Total numbers (e.g., 49).
        t (int): Size of each subset (e.g., 5).
    
    Returns:
        set: A set of integers, each representing a t-subset as a bitmask.
    """
    universe = set()
    for comb in itertools.combinations(range(1, n+1), t):
        mask = 0
        for num in comb:
            mask |= 1 << (num - 1)
        universe.add(mask)
    return universe

# ----------------------------------------------
# 3. Candidate Ticket Generation
# ----------------------------------------------
def random_candidate_tickets(n, k, sample_size):
    """
    Generate a list of candidate tickets. Each candidate is a sorted tuple of k numbers chosen from 1 to n.
    
    Args:
        n (int): Total numbers (e.g., 49).
        k (int): Ticket size (e.g., 6).
        sample_size (int): Number of candidate tickets to generate in each iteration.
    
    Returns:
        list: A list of candidate tickets (each as a tuple).
    """
    candidates = []
    numbers = list(range(1, n+1))
    for _ in range(sample_size):
        candidate = tuple(sorted(random.sample(numbers, k)))
        candidates.append(candidate)
    return candidates

# ----------------------------------------------
# 4. Candidate Evaluation
# ----------------------------------------------
def evaluate_candidate(ticket, universe, t):
    """
    Evaluate a candidate ticket by counting how many of its t-subsets (as bitmasks) are still present in the universe.
    
    Args:
        ticket (tuple): A candidate ticket (tuple of numbers).
        universe (set): The current set of uncovered t-subset bitmasks.
        t (int): The size of the subsets to cover.
    
    Returns:
        tuple: (ticket, count, covered)
            - ticket: the candidate ticket.
            - count: number of t-subsets of the ticket that are in the universe.
            - covered: list of the covered t-subset bitmasks.
    """
    subsets = get_ticket_t_subsets(ticket, t)
    covered = [subset for subset in subsets if subset in universe]
    return (ticket, len(covered), covered)

# ----------------------------------------------
# 5. Build the Lottery Wheel (Single-Threaded)
# ----------------------------------------------
def build_lottery_wheel(n=49, k=6, t=5, sample_size=10000):
    """
    Build a lottery wheel that covers all t-element subsets of {1,...,n} using tickets of size k.
    This version is single-threaded and uses a greedy algorithm with random candidate sampling.
    
    Args:
        n (int): Total numbers (default 49).
        k (int): Size of each ticket (default 6).
        t (int): Size of the subsets to cover (default 5).
        sample_size (int): Number of candidate tickets generated per iteration.
    
    Returns:
        list: A list of chosen tickets (each as a tuple of numbers).
    """
    print(f"Generating universe of all {t}-element subsets of numbers 1 to {n}...")
    start_time = time.time()
    universe = generate_universe(n, t)
    print(f"Universe generated: {len(universe)} subsets in {time.time() - start_time:.2f} seconds.\n")
    
    wheel = []  # List to hold our chosen tickets.
    iteration = 0
    
    while universe:
        iteration += 1
        best_candidate = None
        best_count = 0
        best_covered = []
        
        # Generate a pool of candidate tickets.
        candidates = random_candidate_tickets(n, k, sample_size)
        
        for candidate in candidates:
            ticket, count, covered = evaluate_candidate(candidate, universe, t)
            if count > best_count:
                best_candidate = candidate
                best_count = count
                best_covered = covered
                # Maximum possible t-subsets covered by a ticket is C(k, t).
                # If we achieve that, we can break early.
                if best_count == len(get_ticket_t_subsets(candidate, t)):
                    break
        
        if best_candidate is None:
            print("No candidate found that covers any new subsets. Exiting loop.")
            break
        
        wheel.append(best_candidate)
        # Remove the covered t-subsets from the universe.
        for subset in best_covered:
            universe.discard(subset)
        
        print(f"Iteration {iteration}: Chose ticket {best_candidate} covering {best_count} new subsets; {len(universe)} subsets remain.")
    
    return wheel

# ----------------------------------------------
# 6. Main Function to Run the Code
# ----------------------------------------------
def main():
    # Set parameters: For a typical lottery wheel, these might be:
    # n = 49 (numbers 1 to 49), k = 6 (tickets have 6 numbers), t = 5 (cover all 5-element subsets)
    n = 49
    k = 6
    t = 5
    sample_size = 10000  # You may adjust this based on performance vs. solution quality.
    
    # Build the lottery wheel.
    wheel = build_lottery_wheel(n, k, t, sample_size)
    
    print("\nLottery wheel generated with", len(wheel), "tickets:")
    for ticket in wheel:
        print(ticket)

if __name__ == '__main__':
    main()
