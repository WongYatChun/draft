import itertools
import random
import time
from functools import lru_cache
import concurrent.futures

# -----------------------------
# Caching: Compute the 5-subsets of a ticket (as bitmasks)
# -----------------------------
@lru_cache(maxsize=None)
def get_ticket_5_subsets(ticket):
    """
    Given a ticket (a tuple of 6 sorted numbers), compute the 6 bitmask representations
    of its 5-number subsets. A ticket is represented as a tuple (e.g., (3, 7, 11, 20, 35, 49)).
    Returns a tuple of 6 integers (bitmasks).
    """
    mask = 0
    for num in ticket:
        mask |= 1 << (num - 1)
    # Each 5-set is the ticket mask with one number removed.
    return tuple(mask & ~(1 << (num - 1)) for num in ticket)

# -----------------------------
# Universe Generation: All 5-element subsets as bitmasks
# -----------------------------
def generate_universe(n=49, t=5):
    """
    Generate the universe of all t-element subsets (as bitmasks) from numbers 1 to n.
    For n=49 and t=5, there are binom(49,5) subsets.
    """
    universe = set()
    for comb in itertools.combinations(range(1, n+1), t):
        mask = 0
        for num in comb:
            mask |= 1 << (num - 1)
        universe.add(mask)
    return universe

# -----------------------------
# Candidate Generation
# -----------------------------
def random_candidate_tickets(n, k, sample_size):
    """
    Generate a list of candidate tickets.
    
    Args:
        n (int): Total numbers available (from 1 to n).
        k (int): Ticket size (for lottery, k=6).
        sample_size (int): How many random candidate tickets to generate.
        
    Returns:
        List[tuple]: A list of candidate tickets, each represented as a sorted tuple.
    """
    candidates = []
    numbers = list(range(1, n+1))
    for _ in range(sample_size):
        candidate = tuple(sorted(random.sample(numbers, k)))
        candidates.append(candidate)
    return candidates

# -----------------------------
# Candidate Evaluation (to be parallelized)
# -----------------------------
def evaluate_candidate(ticket, universe):
    """
    Evaluate a candidate ticket by checking how many of its 5-subsets
    (obtained via the cached get_ticket_5_subsets function) are still in the universe.
    
    Args:
        ticket (tuple): A candidate ticket (a tuple of 6 sorted numbers).
        universe (set): The current set of uncovered 5-subset bitmasks.
    
    Returns:
        A tuple (ticket, count, covered) where:
            - ticket: the candidate ticket.
            - count: number of 5-subsets covered by the ticket that are in the universe.
            - covered: a list of the covered 5-subset bitmasks.
    """
    subsets = get_ticket_5_subsets(ticket)
    covered = [subset for subset in subsets if subset in universe]
    return (ticket, len(covered), covered)

# -----------------------------
# Lottery Wheel Builder with Caching & Parallel Processing
# -----------------------------
def build_lottery_wheel_optimized_parallel(n=49, k=6, t=5, sample_size=10000, num_workers=8):
    """
    Build a lottery wheel that covers all t-element subsets (t=5) of {1,...,n}
    using tickets (k=6). This version uses a greedy algorithm with:
      - Cached computation of 5-subsets for each ticket.
      - Parallel candidate evaluation using a ThreadPoolExecutor.
    
    Args:
        n (int): Total numbers (default 49).
        k (int): Size of each ticket (default 6).
        t (int): Size of the subsets to cover (default 5).
        sample_size (int): Number of candidate tickets generated per iteration.
        num_workers (int): Number of worker threads for parallel processing.
    
    Returns:
        List[tuple]: The list of chosen tickets (each as a tuple of numbers).
    """
    print(f"Generating universe of all {t}-element subsets (as bitmasks) from 1..{n}...")
    start_time = time.time()
    universe = generate_universe(n, t)
    print(f"Universe generated: {len(universe)} subsets in {time.time() - start_time:.1f} seconds.\n")
    
    wheel = []  # List to hold our chosen tickets.
    iteration = 0
    
    while universe:
        iteration += 1
        best_candidate = None
        best_count = 0
        best_covered = []
        
        # Generate a pool of candidate tickets.
        candidates = random_candidate_tickets(n, k, sample_size)
        
        # Evaluate candidates in parallel using threads.
        with concurrent.futures.ThreadPoolExecutor(max_workers=num_workers) as executor:
            # Submit candidate evaluations.
            futures = {executor.submit(evaluate_candidate, candidate, universe): candidate for candidate in candidates}
            for future in concurrent.futures.as_completed(futures):
                ticket, count, covered = future.result()
                if count > best_count:
                    best_count = count
                    best_candidate = ticket
                    best_covered = covered
                    # Since a 6-set covers at most 6 five-subsets, we can break early.
                    if best_count == k:
                        break
        
        if best_candidate is None:
            print("No candidate found that covers any new subsets. Exiting loop.")
            break
        
        wheel.append(best_candidate)
        # Remove the covered subsets from the universe.
        for subset in best_covered:
            universe.discard(subset)
        
        print(f"Iteration {iteration}: Chose ticket {best_candidate} covering {best_count} new subsets; {len(universe)} subsets remain.")
    
    return wheel

# -----------------------------
# Main execution
# -----------------------------
if __name__ == '__main__':
    # Warning: Running with full parameters (n=49, k=6, t=5) may take time.
    # You may wish to experiment with a smaller instance first.
    
    # Build the lottery wheel with caching and parallel processing.
    wheel = build_lottery_wheel_optimized_parallel(n=49, k=6, t=5, sample_size=10000, num_workers=8)
    
    print("\nOptimized Parallel Lottery wheel generated with", len(wheel), "tickets:")
    for ticket in wheel:
        print(ticket)
