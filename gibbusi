import numpy as np
import pandas as pd

def exponential_decay_weights(N, half_life=None, normalize='sum_to_N'):
    """
    Generate an array of weights based on exponential decay or equal weighting.

    Parameters:
    - N (int): Number of data points (must be a positive integer).
    - half_life (float or None): Half-life period (must be positive).
        If None, assigns equal weights to all data points.
    - normalize (str): Normalization method. Options:
        - 'raw': No normalization; raw exponential decay weights or equal weights if half_life is None.
        - 'sum_to_1': Normalize weights so that their sum equals 1.
        - 'sum_to_N': Normalize weights so that their sum equals N.
      Default is 'sum_to_N'.

    Returns:
    - weights (numpy.ndarray): Array of weights based on the chosen normalization.
    """
    # Input Validation
    if not isinstance(N, int) or N <= 0:
        raise ValueError("Number of data points N must be a positive integer.")
    
    if half_life is not None and half_life <= 0:
        raise ValueError("Half-life must be positive or None.")
    
    if normalize not in ['raw', 'sum_to_1', 'sum_to_N']:
        raise ValueError("normalize must be one of 'raw', 'sum_to_1', or 'sum_to_N'.")

    # Weight Generation
    if half_life is None:
        # Assign equal weights
        weights = np.ones(N)
    else:
        # Calculate the decay constant
        lambda_ = np.log(2) / half_life

        # Generate weights: w_k = e^(-lambda * k) for k = 0 to N-1
        k = np.arange(N)
        weights = np.exp(-lambda_ * k)

    # Apply normalization based on the 'normalize' parameter
    if normalize == 'sum_to_1':
        weights /= weights.sum()
    elif normalize == 'sum_to_N':
        weights *= (N / weights.sum())
    # If 'raw', do nothing

    return weights

def perform_svd(R, n_components=None):
    """
    Perform Singular Value Decomposition (SVD) and truncate to retain top components.

    Parameters:
    - R (numpy.ndarray): Input matrix of shape (n_assets, n_time_periods).
    - n_components (int): Number of principal components to retain.

    Returns:
    - U_truncated (numpy.ndarray): Truncated left singular vectors (loadings).
    - S_truncated (numpy.ndarray): Truncated singular values.
    - Vt_truncated (numpy.ndarray): Truncated right singular vectors (time factors).
    """
    U, S, Vt = np.linalg.svd(R, full_matrices=False)
    if n_components is not None:
        U = U[:, :n_components]
        S = S[:n_components]
        Vt = Vt[:n_components, :]
    return U, S, Vt

def estimate_idiosyncratic_variances(R, U_p, S_p, Vt_p):
    """
    Estimate idiosyncratic variances for each asset.

    Parameters:
    - R (numpy.ndarray): Original return matrix of shape (n_assets, n_time_periods).
    - U_p (numpy.ndarray): Truncated left singular vectors from first stage PCA (n_assets, p).
    - S_p (numpy.ndarray): Truncated singular values from first stage PCA (p,).
    - Vt_p (numpy.ndarray): Truncated right singular vectors from first stage PCA (p, n_time_periods).

    Returns:
    - sigma_squared (numpy.ndarray): Idiosyncratic variances for each asset (n_assets,).
    """
    # Reconstruct the approximated return matrix
    R_explained = U_p @ np.diag(S_p) @ Vt_p  # Shape: (n_assets, n_time_periods)

    # Compute idiosyncratic returns (residuals)
    residuals = R - R_explained  # Shape: (n_assets, n_time_periods)

    # Compute squared residuals
    residuals_squared = residuals ** 2  # Shape: (n_assets, n_time_periods)

    # Compute idiosyncratic variances as the mean of squared residuals
    sigma_squared = residuals_squared.mean(axis=1)  # Shape: (n_assets,)

    # Handle potential division by zero by adding a small epsilon where sigma_squared is zero
    epsilon = 1e-8
    sigma_squared = np.where(sigma_squared == 0, epsilon, sigma_squared)

    return sigma_squared

class FactorModelEstimator:
    def __init__(self, tau_fast, tau_slow, n_first_pca_component, n_second_pca_component):
        """
        Initialize the FactorModelEstimator.

        Parameters:
        - tau_fast (float): Fast half-life for time-series weighting.
        - tau_slow (float): Slow half-life for time-series weighting.
        - n_first_pca_component (int): Number of principal components to retain in the first stage.
        - n_second_pca_component (int): Number of final factors to retain in the second stage.
        """        
        self.tau_fast = tau_fast
        self.tau_slow = tau_slow
        self.n_first_pca_component = n_first_pca_component
        self.n_second_pca_component = n_second_pca_component
        self.intermediate = {}  # Dictionary to store all intermediate and final values

    def fit(self, R):
        """
        Fit the two-stage PCA factor model to the return matrix.

        Parameters:
        - R (numpy.ndarray): Return matrix of shape (n_assets, n_time_periods).

        Returns:
        - None
        """
        n_assets, n_periods = R.shape

        # Step 1: Generate fast and slow exponential decay weights
        weights_fast = exponential_decay_weights(N=n_periods, half_life=self.tau_fast, normalize='sum_to_N')
        weights_slow = exponential_decay_weights(N=n_periods, half_life=self.tau_slow, normalize='sum_to_N')
        self.intermediate['weights_fast'] = weights_fast
        self.intermediate['weights_slow'] = weights_slow

        # Step 2: Create diagonal weighting matrices
        W_tau_fast = np.diag(weights_fast)    # Shape: (n_periods, n_periods)
        W_tau_slow = np.diag(weights_slow)    # Shape: (n_periods, n_periods)
        self.intermediate['W_tau_fast'] = W_tau_fast
        self.intermediate['W_tau_slow'] = W_tau_slow

        # Step 3: Apply fast weighting to the return matrix (First Stage)
        tilde_R_first_pca = R @ W_tau_fast    # Shape: (n_assets, n_periods)
        self.intermediate['tilde_R_first_pca'] = tilde_R_first_pca

        # Step 4: Perform first stage PCA
        U_first_pca, S_first_pca, Vt_first_pca = perform_svd(tilde_R_first_pca, self.n_first_pca_component)
        self.intermediate['U_first_pca'] = U_first_pca
        self.intermediate['S_first_pca'] = S_first_pca
        self.intermediate['Vt_first_pca'] = Vt_first_pca

        # Step 5: Estimate idiosyncratic variances
        sigma_squared = estimate_idiosyncratic_variances(R, U_first_pca, S_first_pca, Vt_first_pca)  # Shape: (n_assets,)
        self.intermediate['sigma_squared'] = sigma_squared

        # Step 6: Create idiosyncratic variance matrix D
        D = np.diag(sigma_squared)              # Shape: (n_assets, n_assets)
        self.intermediate['D'] = D

        # Step 7: Create idiosyncratic weighting matrix W_idio = diag(1 / sigma_i)
        sigma = np.sqrt(sigma_squared)          # Shape: (n_assets,)
        sigma_inv = 1 / sigma                    # Shape: (n_assets,)
        W_idio = np.diag(sigma_inv)             # Shape: (n_assets, n_assets)
        self.intermediate['W_idio'] = W_idio

        # Step 8: Apply idiosyncratic and slow weighting to the return matrix (Second Stage)
        hat_R_second_pca = W_idio @ R @ W_tau_slow  # Shape: (n_assets, n_periods)
        self.intermediate['hat_R_second_pca'] = hat_R_second_pca

        # Step 9: Perform second stage PCA
        U_second_pca, S_second_pca, Vt_second_pca = perform_svd(hat_R_second_pca, self.n_second_pca_component)
        self.intermediate['U_second_pca'] = U_second_pca
        self.intermediate['S_second_pca'] = S_second_pca
        self.intermediate['Vt_second_pca'] = Vt_second_pca

        # Step 10: Assemble the final factor loadings matrix B = diag(sigma) @ U_second_pca
        B = np.diag(sigma) @ U_second_pca                 # Shape: (n_assets, n_second_pca_component)
        self.intermediate['B'] = B

        # Step 11: Define factor variances based on singular values
        factor_variances = S_second_pca ** 2          # Shape: (n_second_pca_component,)
        self.intermediate['factor_variances'] = factor_variances

        # Step 12: Compute lambda_bar as the average of the remaining singular values squared
        # Since we've truncated to n_second_pca_component, if there are more singular values,
        # compute the mean of their squares. Otherwise, set lambda_bar to zero.
        if self.n_second_pca_component < len(S_second_pca):
            remaining_singular_values = S_second_pca[self.n_second_pca_component:]
            lambda_bar = np.mean(remaining_singular_values ** 2)
        else:
            lambda_bar = 0  # No remaining singular values
        self.intermediate['lambda_bar'] = lambda_bar

    def get_intermediate(self, key):
        """
        Retrieve a specific intermediate value by key.

        Parameters:
        - key (str): The key corresponding to the desired intermediate value.

        Returns:
        - The requested intermediate value.

        Raises:
        - KeyError: If the key does not exist in the intermediate dictionary.
        """
        if key not in self.intermediate:
            raise KeyError(f"Intermediate value '{key}' not found.")
        return self.intermediate[key]

    def get_loadings(self):
        """
        Get the factor loadings matrix.

        Returns:
        - B (numpy.ndarray): Factor loadings matrix of shape (n_assets, n_second_pca_component).

        Raises:
        - ValueError: If the model has not been fitted yet.
        """
        if 'B' not in self.intermediate:
            raise ValueError("The model has not been fitted yet. Call the 'fit' method first.")
        return self.intermediate['B']

    def get_factor_variances(self):
        """
        Get the variances of the factors.

        Returns:
        - factor_variances (numpy.ndarray): Variances of the factors of shape (n_second_pca_component,).

        Raises:
        - ValueError: If the model has not been fitted yet.
        """
        if 'factor_variances' not in self.intermediate:
            raise ValueError("The model has not been fitted yet. Call the 'fit' method first.")
        return self.intermediate['factor_variances']

    def get_lambda_bar(self):
        """
        Get lambda_bar, the average idiosyncratic variance.

        Returns:
        - lambda_bar (float): Average idiosyncratic variance.

        Raises:
        - ValueError: If the model has not been fitted yet.
        """
        if 'lambda_bar' not in self.intermediate:
            raise ValueError("The model has not been fitted yet. Call the 'fit' method first.")
        return self.intermediate['lambda_bar']

    def get_idiosyncratic_variance_matrix(self):
        """
        Get the idiosyncratic variance matrix D.

        Returns:
        - D (numpy.ndarray): Diagonal idiosyncratic variance matrix of shape (n_assets, n_assets).

        Raises:
        - ValueError: If the model has not been fitted yet.
        """
        if 'D' not in self.intermediate:
            raise ValueError("The model has not been fitted yet. Call the 'fit' method first.")
        return self.intermediate['D']

    def calculate_factor_returns(self, R_new):
        """
        Calculate factor returns given new return data.

        Parameters:
        - R_new (numpy.ndarray or pandas.DataFrame): New return matrix of shape (n_assets, n_time_periods).

        Returns:
        - f_new (numpy.ndarray): Factor returns of shape (n_second_pca_component, n_time_periods).

        Raises:
        - ValueError: If the model has not been fitted yet.
        """
        if isinstance(R_new, pd.DataFrame):
            R_new = R_new.values
        required_keys = ['U_second_pca', 'W_idio']
        for key in required_keys:
            if key not in self.intermediate:
                raise ValueError(f"The model has not been fitted yet. Missing '{key}'.")
        U_second_pca = self.intermediate['U_second_pca']
        W_idio = self.intermediate['W_idio']
        f_new = U_second_pca.T @ W_idio @ R_new
        
        return f_new

    def calculate_idio_returns(self, R_new):
        """
        Calculate asset idiosyncratic returns given new return data.

        Parameters:
        - R_new (numpy.ndarray or pandas.DataFrame): New return matrix of shape (n_assets, n_time_periods).

        Returns:
        - idio_new (numpy.ndarray): Idiosyncratic returns of shape (n_assets, n_time_periods).

        Raises:
        - ValueError: If the model has not been fitted yet.
        """
        if isinstance(R_new, pd.DataFrame):
            R_new = R_new.values
        required_keys = ['U_second_pca', 'W_idio', 'B']
        for key in required_keys:
            if key not in self.intermediate:
                raise ValueError(f"The model has not been fitted yet. Missing '{key}'.")
        f_new = self.calculate_factor_returns(R_new)
        B = self.intermediate['B']
        idio_new = R_new - B @ f_new
        
        return idio_new
