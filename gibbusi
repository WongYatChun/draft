import tensorflow as tf
import numpy as np

class WeightPredictorModel:
    def __init__(self, input_shape, hidden_units=10, patience=10, batch_size=32, epochs=1000):
        self.input_shape = input_shape
        self.hidden_units = hidden_units
        self.patience = patience
        self.batch_size = batch_size
        self.epochs = epochs
        self.model = self.build_model()
        self.optimizer = tf.optimizers.Adam()

    def build_model(self):
        input_features = tf.keras.Input(shape=(self.input_shape,))
        hidden_layer = tf.keras.layers.Dense(self.hidden_units, activation='relu')(input_features)
        predicted_weights = tf.keras.layers.Dense(self.input_shape, activation='linear')(hidden_layer)
        model = tf.keras.Model(inputs=input_features, outputs=predicted_weights)
        model.summary()  # Print model summary
        return model

    def custom_loss(self, y_true, y_pred, X_batch):
        predictions = tf.reduce_sum(X_batch * y_pred, axis=1)
        loss = tf.reduce_mean(tf.square(predictions - y_true))
        return loss

    @tf.function
    def train_step(self, X_batch, Y_batch):
        with tf.GradientTape() as tape:
            weights_batch = self.model(X_batch, training=True)
            loss = self.custom_loss(Y_batch, weights_batch, X_batch)
        gradients = tape.gradient(loss, self.model.trainable_variables)
        self.optimizer.apply_gradients(zip(gradients, self.model.trainable_variables))
        return loss

    def train(self, X, Y):
        best_loss = float('inf')
        wait = 0

        dataset = tf.data.Dataset.from_tensor_slices((X, Y)).batch(self.batch_size)

        for epoch in range(self.epochs):
            epoch_loss = 0
            for X_batch, Y_batch in dataset:
                batch_loss = self.train_step(X_batch, Y_batch)
                epoch_loss += batch_loss.numpy()

            epoch_loss /= len(dataset)

            if epoch % 100 == 0:
                print(f"Epoch {epoch}, Loss: {epoch_loss}")

            # Early stopping check
            if epoch_loss < best_loss:
                best_loss = epoch_loss
                wait = 0
            else:
                wait += 1
                if wait >= self.patience:
                    print(f"Early stopping at epoch {epoch}")
                    break

    def predict_weights(self, X):
        return self.model.predict(X)

    def evaluate(self, X, Y):
        predicted_weights = self.predict_weights(X)
        predictions = np.sum(X * predicted_weights, axis=1)
        print("Predicted Y:", predictions[:5])
        print("Actual Y:", Y[:5])
        return predicted_weights, predictions

# Example usage
np.random.seed(0)
X = np.random.rand(100, 3).astype(np.float32)  # 100 samples, 3 features
true_weights = np.array([1.5, -2.0, 1.0], dtype=np.float32)
Y = (X @ true_weights + np.random.normal(0, 0.1, 100)).astype(np.float32)  # Adding some noise

model = WeightPredictorModel(input_shape=X.shape[1])
model.train(X, Y)
predicted_weights, predictions = model.evaluate(X, Y)

print("Predicted weights for the first 5 samples:")
print(predicted_weights[:5])
