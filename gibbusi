import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset

class WeightPredictorModel(nn.Module):
    def __init__(self, input_dim, hidden_units=10):
        super(WeightPredictorModel, self).__init__()
        self.hidden = nn.Linear(input_dim, hidden_units)
        self.output = nn.Linear(hidden_units, input_dim)
    
    def forward(self, x):
        x = torch.relu(self.hidden(x))
        x = self.output(x)
        return x

def custom_loss(y_true, y_pred, X):
    predictions = torch.sum(X * y_pred, axis=1)
    loss = torch.mean((predictions - y_true) ** 2)
    return loss

def train_model(model, dataloader, optimizer, patience=10, max_epochs=1000):
    best_loss = float('inf')
    wait = 0

    for epoch in range(max_epochs):
        epoch_loss = 0.0
        for X_batch, Y_batch in dataloader:
            optimizer.zero_grad()
            weights_batch = model(X_batch)
            loss = custom_loss(Y_batch, weights_batch, X_batch)
            loss.backward()
            optimizer.step()
            epoch_loss += loss.item()

        epoch_loss /= len(dataloader)

        if epoch % 100 == 0:
            print(f"Epoch {epoch}, Loss: {epoch_loss}")

        # Early stopping check
        if epoch_loss < best_loss:
            best_loss = epoch_loss
            wait = 0
        else:
            wait += 1
            if wait >= patience:
                print(f"Early stopping at epoch {epoch}")
                break

def evaluate_model(model, X, Y):
    model.eval()
    with torch.no_grad():
        predicted_weights = model(X).numpy()
        predictions = torch.sum(X * torch.tensor(predicted_weights), axis=1).numpy()
    
    print("Predicted Y:", predictions[:5])
    print("Actual Y:", Y.numpy()[:5])
    return predicted_weights, predictions

# Example usage
np.random.seed(0)
torch.manual_seed(0)
X = np.random.rand(1000, 3).astype(np.float32)
true_weights = np.array([1.5, -2.0, 1.0], dtype=np.float32)
Y = (X @ true_weights + np.random.normal(0, 0.1, 1000)).astype(np.float32)

# Convert to PyTorch tensors
X_tensor = torch.tensor(X)
Y_tensor = torch.tensor(Y)

# Create DataLoader
dataset = TensorDataset(X_tensor, Y_tensor)
dataloader = DataLoader(dataset, batch_size=32, shuffle=True)

# Initialize model, optimizer
model = WeightPredictorModel(input_dim=X.shape[1])
optimizer = optim.Adam(model.parameters(), lr=0.01)

# Train the model
train_model(model, dataloader, optimizer)

# Evaluate the model
predicted_weights, predictions = evaluate_model(model, X_tensor, Y_tensor)

print("Predicted weights for the first 5 samples:")
print(predicted_weights[:5])
