import random
import pandas as pd
from tqdm import tqdm

# Load covering design wheel from files.
def load_tickets(filepath):
    with open(filepath, "r") as file:
        lines = file.readlines()
    return [set(map(int, line.split())) for line in lines]

schedule = load_tickets("/kaggle/input/cover-design/49060306163.txt")


# Create the original list of numbers (1 to 49).
numbers_original = list(range(1, 50))

# Dictionary to store 100 different generated lists.
number_of_generated_list = 10000

generated_dict = {}

# Generate 100 different lists.
for i in tqdm(range(number_of_generated_list)):
    # Create a new shuffled copy of the numbers.
    numbers = numbers_original.copy()
    random.shuffle(numbers)
    
    # Use the schedule to pick numbers from the shuffled list.
    current_list = []
    for indices in schedule:
        combination = [numbers[j-1] for j in indices]
        current_list.append(combination)
    
    # Use a unique key for each generated list, e.g., 'list_1', 'list_2', etc.
    key = f"list_{i+1:03}"
    generated_dict[key] = current_list


# Dictionary to store the total score for each list.
list_scores = {}

# Evaluate each list in the generated dictionary.
for list_key, list_of_sets in tqdm(generated_dict.items()):
    total_score = 0
    for combination in list_of_sets:
        # Count the odd numbers in the combination.
        odd_count = sum(1 for number in combination if number % 2 == 1)
        # Count the numbers that are smaller than 25.
        less_than_25_count = sum(1 for number in combination if number < 25)
        
        # Check if the combination meets both constraints.
        if not (2 <= odd_count <= 4 and 2 <= less_than_25_count <= 4):
            total_score += -1  # Violation detected, score -1.
        else:
            total_score += 0   # Meets the constraints, score 0.
    
    # Store the total score for this list.
    list_scores[list_key] = total_score


pd.DataFrame(list_scores, index = [0]).T.sort_values(0)

import numpy as np

# Simulate 10,000 draws of 7 numbers from 1 to 49 (Mark Six lottery)
def simulate_mark_six_draws(num_draws=10000):
    draws = np.zeros((num_draws, 7), dtype=int)
    for i in range(num_draws):
        draws[i] = sorted(random.sample(range(1, 50), 7))
    return draws

# Simulate the draws
simulated_draws = simulate_mark_six_draws(10000)

# Display the results (you can print it or save it as a file)
print(simulated_draws[1:5])


# -------------------------
# Part 3a: Scoring Using a Loop Over Combinations (Vectorized over Draws)
# -------------------------

def calculate_average_points_for_ticket(ticket, draws):
    """
    Calculate average points per draw for a ticket.
    For each combination in the ticket, we use np.isin over all draws:
      - 4 matches give 1 point
      - 5 matches give 2 points
      - 6 matches give 3 points
    """
    total_points = 0
    for combination in ticket:
        # Convert combination to numpy array (if not already)
        comb_arr = np.array(combination)
        # For each draw, count how many numbers are in the combination.
        # np.isin returns a boolean array of shape (num_draws, 7)
        match_counts = np.sum(np.isin(draws, comb_arr), axis=1)
        # Calculate points for this combination: 1 point for 4 matches, 2 for 5, 3 for 6.
        # points = np.where(match_counts == 4, 1, 0) \
        #          + np.where(match_counts == 5, 2, 0) \
        #          + np.where(match_counts == 6, 3, 0)
        points = np.where(match_counts > 4, 1, 0)
        total_points += points
    # Return the average points per draw
    return total_points / draws.shape[0]

average_points_by_ticket = {}

for ticket_name, ticket in tqdm(generated_dict.items()):
        
    avg_points_vectorized = calculate_average_points_for_ticket(ticket, simulated_draws)
    
    average_points_by_ticket[ticket_name] = avg_points  # both methods should give the same result
    
pd.DataFrame(average_points_by_ticket, index = [0]).T.sort_values(0)


# Lottery simulation parameters
TOTAL_NUMBERS = 49
TICKET_SIZE = 6
DRAW_SIZE = 6
WIN_THRESHOLD = 4
NUM_SIMULATIONS = 100000


# Helper function to simulate one lottery draw (returns a set of drawn numbers)
def draw_numbers():
    return set(random.sample(range(1, TOTAL_NUMBERS + 1), DRAW_SIZE))

# Simulation function: returns the fraction of draws covered (i.e., at least one ticket gets WIN_THRESHOLD or more matches)
def simulation(tickets):
    win_count = 0
    for _ in range(NUM_SIMULATIONS):
        draw = draw_numbers()
        # Check if at least one ticket has WIN_THRESHOLD or more matching numbers.
        if any(len(ticket & draw) >= WIN_THRESHOLD for ticket in tickets):
            win_count += 1
    return win_count / NUM_SIMULATIONS
